多线程: 进程、线程和纤程 ->进程是资源分配的最小单位 线程是进程内部的共享进程资源的操作系统资源调度的基本单位。纤程：是用户态的线程，是线程中的线程，切换和调度不需要经过OS(操作系统)。


线程协作： 见图
    sleep(): 不会释放锁。
    wait(): 释放锁进入阻塞。
    notify(): 唤醒随机一个线程。
    notifyAll(): 唤醒所有线程。
    使用wait()和notifyAll()实现简单的池资源： src/main/java/Thread/pool/MyThreadPool.java

关键字:
    synchronized:
        对象锁。（无论是普通对象还是class对象）
        加锁之后自动解锁，可由编译后的class文件看出。
        重量级锁，需要操作系统调度。
    volatile:  （保证基本数据类型，对象引用无法保证）
        禁止指令重排序
        保证可见性
        不保证原子性(无法实现线程同步)

线程同步:
    锁：
       synchronized 具体见上  锁升级: 无锁->偏向锁->自旋锁（消耗cpu，加锁速度快）->重量级锁（需要操作系统参与调度，加锁速度慢）
       cas 自旋锁：
        实现：
            java.util.concurrent.atomic 包下的api 采用cas(自旋锁)进行锁优化保证对象的线程同步
            java.util.concurrent.locks  ReentrantLock 实现AQS 融合 cas进行线程的加锁排队唤醒操作
基本支持:
    cas：Unsafe类， 基本原理每次操作前先获取指定地址所存储的对象，操作之后在赋值的时候会对比当前指定地址所存储的对象和开始拿到的是否一样，若一至则认为可以赋值，若不一致则再次重复。
        问题: ABA问题，加版本号进行规避
    AQS: 采用先入先出队列（CLH）构建锁和同步器的框架，使用LockSupport作为支持挂起和唤醒线程，使用先入先出队列作为等待队列，使用cas进行抢锁。
         流程: 公平锁、不可重入锁：首先判断锁是否被占有，占有则直接排队，没被占有则进行cas抢锁操作。
         可重入锁：不仅仅检查锁是否被占有，还会检查占有锁的线程，同一个线程可多次获取锁
         非公平锁：先进行抢锁，不管是否有排队
          实现：ReentrantLock，CountDownLatch，Semaphore(基于共享锁,可以控制执行的线程数量)，CyclicBarrier(对CountDownLatch的扩展，CountDownLatch是一次性的计数，而CyclicBarrier是循环栅栏)


synchronized: 基于管程（管理共享变量以及共享变量的操作过程）实现,MESA模型即在管程入口会有一个FIFO队列，每个条件变量还有等待队列，条件变量和等待队列就是为了解决同步问题。字节码指令是monitorenter(加锁)和monitorexit(释放锁)，利用操作系统的互斥原语mutex
               重量级锁: sync存在三个等待队列（_cxq、entryList、waitSet）默认策略：多线程竞争的情况下进入先进后出的_cxq队列进行排队，当执行notify时优先将waitSet的链表移动到entryList，其次移动_cxq队列。然后执行entryList队列里面的第一个线程。
               偏向锁: 为了消除锁无竞争状态下锁冲入的开销引入偏向锁，在无竞争状态下游很好的优化效果。
                       在虚拟机启动时会偶4s的延迟加偏向锁，之后所有新创建的对象都是匿名偏向状态（即可以偏向但未指定偏向线程；
                       偏向锁撤销之hashcode：从MarkWord 可以看出，在存储hashcode以后就没有足够的字节保存偏向的线程id了，所以执行hashcode之后就不会存在偏向锁状态了。
                                            如果在偏向锁过程中，调用hashcode会直接变成重量级锁，如果是匿名偏向过程中就升级为轻量级锁。
                       偏向锁撤销之notify和wait: 应为notify和wait都是需要获取monitor所以重量级锁回退是轻量级锁，wait会升级为重量级锁
               轻量级锁：cas 轻微竞争

               重量级锁：内核态，monitor对象  中间会进行多次自适应自旋，自旋的目的是为了减少线程挂起的次数，尽量避免直接挂起线程（挂起操作涉及系统调 用，存在用户态和内核态切换，这才是重量级锁最大的开销）



               锁消除：
               锁粗化：对一个对象连续加锁解锁，就会将锁范围增大，比如StringBuffer 连续append

               逃逸分析： 1.同步省略或者锁消除
                         2.将堆分配转化为粘上分配
                         3.标量替换

