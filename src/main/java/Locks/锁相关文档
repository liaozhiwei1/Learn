多线程: 进程、线程和纤程 ->进程是资源分配的最小单位 线程是进程内部的共享进程资源的操作系统资源调度的基本单位。纤程：是用户态的线程，是线程中的线程，切换和调度不需要经过OS(操作系统)。


线程协作： 见图
    sleep(): 不会释放锁。
    wait(): 释放锁进入阻塞。
    notify(): 唤醒随机一个线程。
    notifyAll(): 唤醒所有线程。
    使用wait()和notifyAll()实现简单的池资源： src/main/java/Thread/pool/MyThreadPool.java

关键字:
    synchronized:
        对象锁。（无论是普通对象还是class对象）
        加锁之后自动解锁，可由编译后的class文件看出。
        重量级锁，需要操作系统调度。
    volatile:  （保证基本数据类型，对象引用无法保证）
        禁止指令重排序
        保证可见性
        不保证原子性(无法实现线程同步)

线程同步:
    锁：
       synchronized 具体见上  锁升级: 无锁->偏向锁->自旋锁（消耗cpu，加锁速度快）->重量级锁（需要操作系统参与调度，加锁速度慢）
       cas 自旋锁：
        实现：
            java.util.concurrent.atomic 包下的api 采用cas(自旋锁)进行锁优化保证对象的线程同步
            java.util.concurrent.locks  ReentrantLock 实现AQS 融合 cas进行线程的加锁排队唤醒操作
基本支持:
    cas：Unsafe类， 基本原理每次操作前先获取指定地址所存储的对象，操作之后在赋值的时候会对比当前指定地址所存储的对象和开始拿到的是否一样，若一至则认为可以赋值，若不一致则再次重复。
        问题: ABA问题，加版本号进行规避
    AQS: 采用先入先出队列（CLH）构建锁和同步器的框架，使用LockSupport作为支持挂起和唤醒线程，使用先入先出队列作为等待队列，使用cas进行抢锁。
         流程: 公平锁、不可重入锁：首先判断锁是否被占有，占有则直接排队，没被占有则进行cas抢锁操作。
         可重入锁：不仅仅检查锁是否被占有，还会检查占有锁的线程，同一个线程可多次获取锁
         非公平锁：每次不管锁是否占有，先进行抢锁。

以上是单节点的多线程高并发编程