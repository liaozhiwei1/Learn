1. sql执行流程: 查询  ---> 是否命中缓存
                                       是 ----> 直接返回
                                       否 ----> 解析sql语句 ----->  优化sql语句  -----> 执行sql语句 -----> 返回结果

2.mysql 逻辑分层: 连接层，服务层，引擎层，存储层

3.innodb:
         innodb是一种事务性存储引擎。
         完全支持事务ACID （刚性事务）
         Redo Log 和 Undo Log
         innodb支持行锁（并发高）

4.锁
    共享锁(读锁)：当一个事务对某几行上锁时，允许其他事务对这几行进行读操作，单不允许其进行写操作，也不允许加拍他所，但允许上读锁。
    排他锁(写锁): 当一个事务对某几行上锁时，不行允许其他事务写，但允许读，更不允许其他事务对这几行加任何锁。
    注意:
        1.两个事务不能锁同一个索引。
        2。insert,delete,update在事务中都会自动默认加上排他锁
        3.行锁必须有索引才能实现，否则会自动锁全表数据，就不能体现行锁了。

    gap锁(间隙锁):锁住数据和数据之间的间隙，解决幻读问题
5.事务:
   ACID:原子性： 通过undo log实现，在每次事务操作数据以后都会将元数据写入并且修改后的数据会有回滚指针指向undoLog文件中的元数据，如果出现回滚就会执行这些语句。
        一致性： 通过undo log实现
        隔离性： 通过锁来实现。
        持久性： 通过redo log实现，如果每次修改数据都去磁盘中刷新的话，大量的磁盘io会导致性能下降，所以采用先写日志，在写磁盘的方式。redo log就是这个日志。
                mysql的数据分为内存和磁盘，而内存的数据会以日志的方式写到redo log上，断电或者宕机重启就只需要加载redo log就能恢复之前在内存中的数据

        隔离性：未提交读（脏读），已提交读（不可重复读），可重复读，可串行化（解决幻读问题，通过加锁）

        脏读，事务A读取了事务B更新的数据，然后事务B进行了回滚，导致A读到的数据是脏数据
        不可重复读，事务A多次读取统一数据，在此期间事务B修改了数据，导致A多次读到的数据不一样  数据不一致
        幻读：事务A在读取统一范围数据时，事务B添加 了数据，导致事务A多次读取的数据数量不一致。  数据数量不一致



        可重复读: 事务A在当前事务里面多次查询某一数据，在此期间事务B对该数据进行了修改并提交，但是事务A读出来的数据依然是第一次读取的数据。

        解决不可重复读的问题只需锁住满足条件的行，
        解决幻读需要锁表（在innodb中采用间隙锁，优于表锁）

6.索引: 一种高效的数据结构
    分类： 普通索引：索引只包含单列
            唯一索引：索引列唯一，且可以为空值
            复合索引：一个索引包含多列
            主键索引:唯一，非空


           聚集索引： 索引和数据在一起
           非聚集索引：索引和数据在一起

        一个查询，命中普通索引或者组合索引的情况下，在叶子节点找到的是主键列的值，需要做回表操作，在利用主键列的值去主键索引上查找，主键索引的叶子节点存储的是真实的数据。
                    也不是所有命中组合索引的查询都需要回表，比如查询的数据就是组合索引的一部分，可以直接获得值。称为覆盖索引。

7。间隙锁会产生死锁问题，解决死锁问题  1.可以设置超时时间自动回滚， 2.可以主动死锁检测。  3.人为kill

8.innodb实现MVCC或者是非阻塞读:表中含有隐藏的两行分别标识创建的事务id和删除的事务id，当一条数据被插入就会记录插入数据的事务id，删除就会记录删除的事务id，
                             更新则是一次删除加一次插入，查询时会更具你这个查询的事务id确定你查询的范围，也就是你当前查询的事务id决定了你的快照版本。
                             如果是使用for update等加锁查询的话，Mvcc不生效，因为是当前版本。
                             重点（解决可重复读的问题  行锁的变种） 行锁不能再修改的时候进行读。

                             事务A修改数据，事务B快照读能否读到事务A修改后的数据取决于，事务B在进行第一次快照读时事务A是否已经提交
                             rc(读已提交) 每次快照读都生成read view  rr(可重复读) 在第一次快照读时生成read view


脏读，不可重复度 （行锁 或者 升级版本MVCC） ---> 可重复读  （间隙锁） -----> 串行化

mysql优化
    查询索引  ：全值匹配我最爱，最左前缀要遵守；

               带头大哥不能死，中间兄弟不能断；

               索引列上少计算，范围之后全失效；

               LIKE百分写最右，覆盖索引不写*；

               不等空值还有OR，索引影响要注意；

               VARCHAR引号不可丢， SQL优化有诀窍。